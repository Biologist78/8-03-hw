# Домашнее задание к занятию "Базы данных" - Пешева Ирина


### Задание 1

Опишите не менее семи таблиц, из которых состоит база данных:

- какие данные хранятся в этих таблицах;
- какой тип данных у столбцов в этих таблицах, если данные хранятся в PostgreSQL.

Приведите решение к следующему виду:

Сотрудники (

- идентификатор, первичный ключ, serial,
- фамилия varchar(50),
- ...
- идентификатор структурного подразделения, внешний ключ, integer).

### Решение 1

#### Исходная таблица

Исходно имеем таблицу (Employees) следующего вида:

| Название ключа | Тип | Аттрибуты |
| --- | --- | --- |
| id | UNSIGNED SMALLINT | NOT NULL, PRIMARY KEY, SERIAL |
| ФИО сотрудника | VARCHAR(64) | NOT NULL |
| Оклад | MONEY | NOT NULL |
| Должность | VARCHAR(64) | NOT NULL |
| Тип подразделения | VARCHAR(16) | NOT NULL |
| Структурное подразделение | VARCHAR(64) | NOT NULL |
| Дата найма | DATE | NOT NULL |
| Адрес филиала | VARCHAR(64) | NOT NULL |
| Проект, на который назначен | varchar | NOT NULL |

Сразу добавим в таблицу id, так как ФИО могут и повторяться.

Если поискать по интернету, можно найти людей с фамилией длиной в 700 символов. Будем надеяться, что такой человек к нам не устроится, берём человека с самым длинным ФИО в таблице (Алексеев Константин Николаевич, 30), для красоты возьмём 64.

Для Оклада выберем тип данных money, раз уж мы используем PostgreSQL. Хотя на некоторых форумах пишут, что его использование не рекомендовано. Но не говорят почему.

Беглый гуглёж говорит, что в России самая длинная должность состоит из 174 символов. Но, ориентируясь на таблицу, берём 35 симвоволов из (руководитель направления разработки) и округляем до 64.

В типах подразделения самое длинное значение – Департамент, 11 символов. Возьмём 16.

В структурных подразделениях самое длинное значение – Центр разработки продуктов для digital-маркетинга, 49 символов. Возьмём 64.

В адресах самое длинное значение – Ростовская обл, г. Ростов-на-Дону, ул 2-я Краснодарская, д. 135/2, 65 символов. Возьмём 128.

В проектах самое длинное значение – {Билайн. Нижний Новгород,Итэлма АМО ЗИЛ}, 40 символов. Возьмём 64.

### Приведение к первой форме нормализации

Значения должны быть атомарными. Посмотрим, что у нас содержит слишком много данных.

ФИО и Адреса филиалов пока пусть живут.

А вот проекты надо бы разбить (если разделение запятой действительно определяет несколько проектов):

**EmployeeProjects**
| Название ключа | Тип | Аттрибуты |
| --- | --- | --- |
| ID сотрудника | UNSIGNED SMALLINT | FOREIGN KEY(Employee.id) |
| Проект | VARCHAR(64) | NOT NULL |

Самое длинное название проекта – Общественное пространство Норильск, 34 символа. 
Возьмём размер в 64.

У проекты вообще говоря тоже не уникальны для каждого человека, так что их тоже выносим в отдельную таблицу:

**Projects**
| Название ключа | Тип | Аттрибуты |
| --- | --- | --- |
| Проект | VARCHAR(64) | NOT NULL |

### Вторая форма нормализации

Здесь, как будто, делать особо нечего, так как FOREIGN KEY – это id сотрудника, и то, что зависит от ключа, зависит от него целиком.

### Третья форма нормализации

Теперь избавимся от того, что зависит от "не ключевых" столбцов.

Оклад как будто ни от чего напрямую не зависит. Видимо, всё зависит от того, насколько человек молодец – но для этого столбца не завели. Пока остаётся в исходной таблице.

Должность вроде тоже исключительно свойство пользователя.

А вот Отдел как будто больше соотносится с должностью. Выносим.

**Positions**
| Название ключа | Тип | Аттрибуты |
| --- | --- | --- |
| Должность | VARCHAR(64) | NOT NULL, UNIQUE, PRIMARY KEY |
| Тип подразделения | VARCHAR(16) | NOT NULL |

Структурное подразделение, в свою очередь, соотносится с Типами подразделения

**Units**
| Название ключа | Тип | Аттрибуты |
| --- | --- | --- |
| Структурное подразделение | VARCHAR(64) | NOT NULL, UNIQUE, PRIMARY KEY |
| Тип подразделения | VARCHAR(16) | NOT NULL |

В этот момент возникает подспудное ощущение, что Тип подразделения пора как-то оформить отдельно, а в предыдущих таблицах использовать какой-нибудь id.

**UnitTypes**
| Название ключа | Тип | Аттрибуты |
| --- | --- | --- |
| Тип подразделения | VARCHAR(16) | NOT NULL, UNIQUE, PRIMARY KEY |

А теперь получилось как-то глупо. У нас и Должность однозначно соотносится с Типом подразделения, и Структурное подразделение. Получается, это просто может быть несколько должностей в каждом Структурном подразделении, а оно уже относится к какому-нибудь типу подразделения.

Нужно будет изменить таблицу **Positions** и создать ещё одну для должностей каждого Структурного подразделения – оттуда уже можно будет судить, какая должность какому Типу подразделения соответствует (а возможно, этого даже не требуется).

**UnitPositions**
| Название ключа | Тип | Аттрибуты |
| Должность | VARCHAR(64) | NOT NULL, FOREIGN KEY(Positions.Должность) |
| Структурное подразделение | VARCHAR(64) | NOT NULL, FOREIGN KEY(Units.Структурное подразделение) |

Дата найма принадлежит сотруднику, пусть остаётся.

Казалось бы, адрес филиала может от чего-нибудь зависеть – ан нет, Группа сервисной поддержки есть и в Краснодаре, и в Ростове-на-Дону. Что по-своему логично.
Между тем, они очевидно составляют всего 3 адреса. Выносим их отдельную таблицу:

**Branches**
| Название ключа | Тип | Аттрибуты |
| --- | --- | --- |
| Адрес филиала | VARCHAR(64) | NOT NULL, UNIQUE, PRIMARY KEY |

Если в том же городе откроется ещё филиал или же в области откроется филиал, можно будет выделить область и город в отдельное значение.

Тогда дополняем таблицы на предмет связей и получаем:

**Employees**
| Название ключа | Тип | Аттрибуты |
| --- | --- | --- |
| id | UNSIGNED SMALLINT | NOT NULL, PRIMARY KEY, SERIAL |
| ФИО сотрудника | VARCHAR(64) | NOT NULL |
| Оклад | MONEY | NOT NULL |
| Должность | VARCHAR(64) | NOT NULL, FOREIGN KEY(UnitPositions.Должность) |
| Структурное подразделение | VARCHAR(64) | NOT NULL, FOREIGN KEY(UnitPositions.Структурное подразделение) |
| Дата найма | DATE | NOT NULL |
| Адрес работы | VARCHAR(64) | NOT NULL, FOREIGN KEY(Branches.id) |

**Projects**
| Название ключа | Тип | Аттрибуты |
| --- | --- | --- |
| Проект | VARCHAR(64) | NOT NULL, UNIQUE, PRIMARY KEY |

**EmployeeProjects**
| Название ключа | Тип | Аттрибуты |
| --- | --- | --- |
| ID сотрудника | UNSIGNED SMALLINT | NOT NULL, PRIMARY KEY, FOREIGN KEY(Employee.id) |
| ID проекта | VARCHAR(64) | NOT NULL, PRIMARY KEY,  FOREIGN KEY(Projects.Проект) |

**UnitTypes**
| Название ключа | Тип | Аттрибуты |
| --- | --- | --- |
| Тип подразделения | VARCHAR(16) | NOT NULL, UNIQUE, PRIMARY KEY |

**Positions**
| Название ключа | Тип | Аттрибуты |
| --- | --- | --- |
| Должность | VARCHAR(64) | NOT NULL, UNIQUE, PRIMARY KEY |

**Units**
| Название ключа | Тип | Аттрибуты |
| --- | --- | --- |
| Структурное подразделение | VARCHAR(64) | NOT NULL, UNIQUE, PRIMARY KEY |
| Тип подразделения | VARCHAR(16) | NOT NULL, FOREIGN KEY(UnitTypes.Тип подразделения) |

**UnitPositions**
| Название ключа | Тип | Аттрибуты |
| --- | --- | --- |
| Должность | VARCHAR(64) | NOT NULL, PRIMARY KEY, FOREIGN KEY(Positions.Должность) |
| Структурное подразделение | VARCHAR(64) | NOT NULL, PRIMARY KEY, FOREIGN KEY(Units.Структурное подразделение) |

**Branches**
| Название ключа | Тип | Аттрибуты |
| --- | --- | --- |
| Адрес филиала | VARCHAR(64) | NOT NULL, UNIQUE, PRIMARY KEY |

Ещё бы можно во все таблицы добавить id, но в целом и нормальные ключи выполняют свою функцию. Тогда мы сэкономим место и при изменении названия чего-либо не придётся проводить каскадных операций.

---

## Дополнительные задания (со звездочкой*)

Эти задания дополнительные (не обязательные к выполнению) и никак не повлияют на получение вами зачета по этому домашнему заданию. Вы можете их выполнить, если хотите глубже и/или шире разобраться в материале.

### Задание 2

Перечислите, какие, на ваш взгляд, в этой денормализованной таблице встречаются функциональные зависимости и какие правила вывода нужно применить, чтобы нормализовать данные.

### Решение 2

Функциональные зависимости:
* Одному **ФИО** (в идеале всё же id сотрудника) соответствуют одно значение **Оклада**, **Должности**, **Структурного подразделения** (соответственно и **Типа подразделения**) **Даты найма** и **Адреса филиала**. В общем, однозначно не определяется только **Проект**.
* **Структурному подразделению** соответствует **Тип подразделения**; 
* **Должности** соответствует **Тип подразделения**, но через аттрибут **Структурное подразделение**.

Правила вывода Армстронга:
* Рефлексивность. Так как аттрибуты **ФИО**, **Оклада**, **Должности**, **Структурного подразделения**, **Типа подразделения** **Даты найма** и **Адреса филиала** все образуют одно множество атрибутов, мы можем по этом множеству определить любой из них. Что с этим делать пока что совершенно неясно, но порадуемся.
* Пополнение. Как будто ничем нам не помогает вообще. Разве что говорит, что можно добавить атрибут в два зависящих набора, *но зачем*.
* Транзитивность. Вот это, наверное, всё, что использовалось на этапе приведения к третьей ворме. 
Если по **id сотрудника** можно определить **Структурное подразделение**, а по **Структурному подразделению** можно определить  **Тип подразделения**, то по **id сотрудника** можно определить **Тип подразделения**. Чем и можно было воспользоваться, вынеся **Тип подразделения** из таблицы вообще.

Из вторичных как будто полезным оказались правила объединения и декомпозиции:
* Так как **id пользователя** определяет **Должность** и **Структурное подразделение** они могут быть объединены. 
* По той же логике они могут быть и разделены.

При этом вынести **Тип подразделения** или **Должность нельзя** из Employees нельзя, так как они друг друг друга напрямую не определяют.

Вообще, никто как будто не берётся объяснять правила на конкретных примерах, а не в математических терминах, так что проще оказалось разносить таблицы не думая о формах вывода. (Вообще говоря, с разрабором на реальных данных есть только видео восьмилетней давности с милой азиатской девушкой.)