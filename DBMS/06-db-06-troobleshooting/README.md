# Домашнее задание к занятию 6. «Troubleshooting»

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD-операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести эту операцию:

- напишите список операций, которые вы будете производить для остановки запроса пользователя;
  - находим операцию - 
  ```db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 180 },
     "ns" : /^db1\./
   }
   )
  ```
  - прерываем выполнение - db.killOp()
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.
  - внедрить систему мониторинга, например связку prometheus+grafana, выяснить насколько частая проблема, при какиз запросах возникает и т.п., те есть выяснить как можно больше информации для определения дальнейших действий.

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причём отношение количества записанных key-value-значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:

- сначала происходит рост отношения записанных значений к истекшим,
- Redis блокирует операции записи.

Как вы думаете, в чём может быть проблема?
    В основном это означает, что если в базе данных есть много-много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% текущей совокупности ключей с установленным сроком действия, Redis может заблокировать, чтобы получить процент ключей, срок действия которых уже истек. ниже 25%.
 
## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базы
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?
Наиболее распространенная причина ошибки заключается в том, что сервер закрыл соединение по тайм-ауту. В этом случае вы обычно получаете один из следующих кодов ошибок (какой из них вы получите, зависит от операционной системы).

Какие пути решения этой проблемы вы можете предложить?
    - Вы получили тайм-аут соединения TCP/IP на стороне клиента. Это может произойти, если вы использовали команды: mysql_options(..., MYSQL_OPT_READ_TIMEOUT,...)или mysql_options(..., MYSQL_OPT_WRITE_TIMEOUT,...). В этом случае увеличение времени ожидания может помочь решить проблему.
    - Вы также можете получить эти ошибки, если отправляете на сервер неверный или слишком большой запрос. Если mysqld получает пакет, который слишком велик или не соответствует порядку, он предполагает, что что-то пошло не так с клиентом, и закрывает соединение. Если вам нужны большие запросы (например, если вы работаете с большими BLOB столбцами), вы можете увеличить лимит запросов, установив переменную сервера max_allowed_packet, которая по умолчанию имеет значение 64 МБ. Вам также может потребоваться увеличить максимальный размер пакета на стороне клиента.


## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объёмом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?
Когда у сервера или процесса заканчивается память, Linux предлагает 2 пути решения: обрушить всю систему или завершить процесс (приложение), который съедает память. Лучше, конечно, завершить процесс и спасти ОС от аварийного завершения. В двух словах, Out-Of-Memory Killer — это процесс, который завершает приложение, чтобы спасти ядро от сбоя. Он жертвует приложением, чтобы сохранить работу ОС.

Как бы вы решили эту проблему?

Стоит пересмотреть БД, возможно шардировать, или вообще пересмотреть архитектруру. Второй вариант кардинально увеличить размер RAM.
Если нет возможности увеличить память или шардировать, а необходимо попробовать заставить данную БД настройками, то можно попробовать править следующие параметры конфигурации:
  - shared_buffers
  - work_mem


---
### Как cдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---

